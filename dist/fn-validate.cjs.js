"use strict";function e(e){return"number"==typeof e}Object.defineProperty(exports,"__esModule",{value:!0});function r(e){return!("function"!=typeof e||!e.call)}const t=e=>e instanceof Promise;const n=/^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/,o=e=>"string"==typeof e||e instanceof String;exports.between=(r,t,n="Should be between "+r+" and "+t)=>o=>{let a=e(o)?o:parseFloat(o);return!Number.isNaN(a)&&(o<r||o>t)?[n]:[]},exports.combine=function(e,t){if(!Array.isArray(e))throw new Error("combine requires that validators are an array of functions");if(0===e.length)return()=>[];for(let t=0,n=e.length;t<n;t++)if(!r(e[t]))throw new Error("Each validator needs to be a function");return 1===e.length?e:!0===t?r=>e.reduce(((e,t)=>e.concat(t(r))),[]):r=>{for(const t of e){let e=t(r);if(e.length>0)return e}return[]}},exports.combineAsync=function(e,n=!1){if(!Array.isArray(e))throw new Error("combineAsync requires that validators are an array of functions");if(0===e.length)return()=>Promise.resolve([]);for(let t=0,n=e.length;t<n;t++)if(!r(e[t]))throw new Error("Each validator needs to be a function");if(1===e.length){const r=e[0];return e=>{var n=r(e);return t(n)?n:Promise.resolve(n)}}return n?r=>function(e,r){const n=e.map((e=>{const n=e(r);return t(n)?n:Promise.resolve(n)}));return Promise.all(n).then((e=>e.reduce(((e,r)=>e.concat(r)),[])))}(e,r):r=>function(e,r){return new Promise(((n,o)=>{let a=!1,s=e.length;for(let i=0,l=e.length;i<l;i++){if(a)return;try{const l=e[i](r),u=t(l);if(!u&&l.length>0){a=!0,n(l);break}u?l.then((e=>{e.length>0?(a=!0,n(e)):0==--s&&n([])})).catch(o):0==--s&&n([])}catch(e){o(e)}}}))}(e,r)},exports.email=(e="Email address is not valid")=>r=>n.test(r)?[]:[e],exports.equalTo=(e,t="Values are not equal")=>{var n=r(e)?e:()=>e;return e=>n()===e?[]:[t]},exports.greaterThan=(e,r="Value is too small")=>t=>t>e?[]:[r],exports.greaterThanOrEqualTo=(e,r="Value is too small")=>t=>t>=e?[]:[r],exports.hasChar=(e="",r="Missing required character")=>(o(e)&&(e=e.split("")),t=>{if(!o(t))return[];for(let r=0,n=e.length;r<n;r++)if(t.indexOf(e[r])>-1)return[];return[r]}),exports.hasLowercase=(e="Requires a lowercase character")=>{var r=/[a-z]/;return t=>o(t)&&r.test(t)?[]:[e]},exports.hasNumeric=(e="Requires a number")=>{var r=/\d/;return t=>o(t)&&r.test(t)?[]:[e]},exports.hasUppercase=(e="Requires an uppercase character")=>{var r=/[A-Z]/;return t=>o(t)&&r.test(t)?[]:[e]},exports.isNumeric=(r="Value is not a valid number")=>t=>e(t)?[]:isNaN(parseFloat(t))?[r]:[],exports.lengthBetween=(e,r,t="Should be between "+e+" and "+r+" in length")=>n=>o(n)&&(n.length<e||n.length>r)?[t]:[],exports.lessThan=(e,r="Value is too large")=>t=>t<e?[]:[r],exports.lessThanOrEqualTo=(e,r="Value is too large")=>t=>t<=e?[]:[r],exports.matches=(e,r="Value doesnt match pattern")=>(e=o(e)?new RegExp(e):e,t=>e.test(t)?[]:[r]),exports.maxLength=(e,r="Too long")=>t=>o(t)&&t.length>e?[r]:[],exports.minLength=(e,r="Not long enough")=>t=>o(t)&&t.length<e?[r]:[],exports.notDefault=(e,r="This is required")=>(e=Array.isArray(e)?e:[e],t=>{for(let n=0,o=e.length;n<o;n++)if(t===e[n])return[r];return[]}),exports.notEqualTo=(e,t="Values should not be the same")=>{var n=r(e)?e:()=>e;return e=>n()!==e?[]:[t]},exports.required=(e="Required")=>r=>r?[]:[e];
//# sourceMappingURL=fn-validate.cjs.js.map
