var fnValidate=function(e){"use strict";const r=e=>"string"==typeof e||e instanceof String,t=(e,t="Value doesnt match pattern")=>(e=r(e)?new RegExp(e):e,r=>e.test(r)?[]:[t]);function n(e){return!("function"!=typeof e||!e.call)}const a=e=>e instanceof Promise;const o=/^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;return e.allowedChars=(e=!0,r=!0,n=!0,a="",o="Value contains restricted characters")=>{let s="^[";return e&&(s+="a-z"),r&&(s+="A-Z"),n&&(s+="0-9"),a&&(s+=a.replace(/[-/\\^$*+?.()|[\]{}]/g,"\\$&")),s+="]*$",t(new RegExp(s),o)},e.between=(e,r,t="Should be between "+e+" and "+r)=>n=>{let a=parseFloat(n);return!isNaN(a)&&(n<e||n>r)?[t]:[]},e.combine=function(e,r){if(!Array.isArray(e))throw new Error("combine requires that validators are an array of functions");if(0===e.length)return()=>[];for(let r=0,t=e.length;r<t;r++)if(!n(e[r]))throw new Error("Each validator needs to be a function");return 1===e.length?e:!0===r?r=>e.reduce(((e,t)=>e.concat(t(r))),[]):r=>{for(const t of e){let e=t(r);if(e.length>0)return e}return[]}},e.combineAsync=function(e,r=!1){if(!Array.isArray(e))throw new Error("combineAsync requires that validators are an array of functions");if(0===e.length)return()=>Promise.resolve([]);for(let r=0,t=e.length;r<t;r++)if(!n(e[r]))throw new Error("Each validator needs to be a function");if(1===e.length){const r=e[0];return e=>{var t=r(e);return a(t)?t:Promise.resolve(t)}}return r?r=>function(e,r){const t=e.map((e=>{const t=e(r);return a(t)?t:Promise.resolve(t)}));return Promise.all(t).then((e=>e.reduce(((e,r)=>e.concat(r)),[])))}(e,r):r=>function(e,r){return new Promise(((t,n)=>{let o=!1,s=e.length;for(let i=0,u=e.length;i<u;i++){if(o)return;try{const u=e[i](r),l=a(u);if(!l&&u.length>0){o=!0,t(u);break}l?u.then((e=>{e.length>0?(o=!0,t(e)):0==--s&&t([])})).catch(n):0==--s&&t([])}catch(e){n(e)}}}))}(e,r)},e.custom=(e,r="Value is incorrect")=>{if(!n(e))throw new Error("func needs to be a function");return t=>e(t)?[]:[r]},e.customAsync=function(e,r="Value is incorrect"){if(!n(e))throw new Error("func needs to be a function");return t=>{const n=e(t);return a(n)?n.then((e=>e?[]:[r])):Promise.resolve(n?[]:[r])}},e.email=(e="Email address is not valid")=>r=>o.test(r)?[]:[e],e.equalTo=(e,r="Values are not equal")=>{var t=n(e)?e:()=>e;return e=>t()===e?[]:[r]},e.greaterThan=(e,r="Value is too small")=>t=>t>e?[]:[r],e.greaterThanOrEqualTo=(e,r="Value is too small")=>t=>t>=e?[]:[r],e.hasChar=(e="",t="Missing required character")=>(r(e)&&(e=e.split("")),n=>{if(!r(n))return[];for(let r=0,t=e.length;r<t;r++)if(n.indexOf(e[r])>-1)return[];return[t]}),e.hasLowercase=(e="Requires a lowercase character")=>{var t=/[a-z]/;return n=>r(n)&&t.test(n)?[]:[e]},e.hasNumeric=(e="Requires a number")=>{var t=/\d/;return n=>r(n)&&t.test(n)?[]:[e]},e.hasUppercase=(e="Requires an uppercase character")=>{var t=/[A-Z]/;return n=>r(n)&&t.test(n)?[]:[e]},e.isNumeric=(e="Value is not a valid number")=>r=>"number"==typeof r?[]:isNaN(parseFloat(r))?[e]:[],e.lengthBetween=(e,t,n="Should be between "+e+" and "+t+" in length")=>a=>r(a)&&(a.length<e||a.length>t)?[n]:[],e.lessThan=(e,r="Value is too large")=>t=>t<e?[]:[r],e.lessThanOrEqualTo=(e,r="Value is too large")=>t=>t<=e?[]:[r],e.matches=t,e.maxLength=(e,t="Too long")=>n=>r(n)&&n.length>e?[t]:[],e.minLength=(e,t="Not long enough")=>n=>r(n)&&n.length<e?[t]:[],e.notDefault=(e,r="This is required")=>(e=Array.isArray(e)?e:[e],t=>{for(let n=0,a=e.length;n<a;n++)if(t===e[n])return[r];return[]}),e.notEqualTo=(e,r="Values should not be the same")=>{var t=n(e)?e:()=>e;return e=>t()!==e?[]:[r]},e.required=(e="This is required")=>r=>r?[]:[e],Object.defineProperty(e,"__esModule",{value:!0}),e}({});
//# sourceMappingURL=fn-validate.min.js.map
