var fnValidate=function(e){"use strict";function r(e){return"number"==typeof e}function t(e){return!("function"!=typeof e||!e.call)}const n=e=>e instanceof Promise;const a=/^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/,o=e=>"string"==typeof e||e instanceof String;return e.between=(e,t,n="Should be between "+e+" and "+t)=>a=>{let o=r(a)?a:parseFloat(a);return!Number.isNaN(o)&&(a<e||a>t)?[n]:[]},e.combine=function(e,r){if(!Array.isArray(e))throw new Error("combine requires that validators are an array of functions");if(0===e.length)return()=>[];for(let r=0,n=e.length;r<n;r++)if(!t(e[r]))throw new Error("Each validator needs to be a function");return 1===e.length?e:!0===r?r=>e.reduce(((e,t)=>e.concat(t(r))),[]):r=>{for(const t of e){let e=t(r);if(e.length>0)return e}return[]}},e.combineAsync=function(e,r=!1){if(!Array.isArray(e))throw new Error("combineAsync requires that validators are an array of functions");if(0===e.length)return()=>Promise.resolve([]);for(let r=0,n=e.length;r<n;r++)if(!t(e[r]))throw new Error("Each validator needs to be a function");if(1===e.length){const r=e[0];return e=>{var t=r(e);return n(t)?t:Promise.resolve(t)}}return r?r=>function(e,r){const t=e.map((e=>{const t=e(r);return n(t)?t:Promise.resolve(t)}));return Promise.all(t).then((e=>e.reduce(((e,r)=>e.concat(r)),[])))}(e,r):r=>function(e,r){return new Promise(((t,a)=>{let o=!1,s=e.length;for(let i=0,u=e.length;i<u;i++){if(o)return;try{const u=e[i](r),l=n(u);if(!l&&u.length>0){o=!0,t(u);break}l?u.then((e=>{e.length>0?(o=!0,t(e)):0==--s&&t([])})).catch(a):0==--s&&t([])}catch(e){a(e)}}}))}(e,r)},e.email=(e="Email address is not valid")=>r=>a.test(r)?[]:[e],e.equalTo=(e,r="Values are not equal")=>{var n=t(e)?e:()=>e;return e=>n()===e?[]:[r]},e.greaterThan=(e,r="Value is too small")=>t=>t>e?[]:[r],e.greaterThanOrEqualTo=(e,r="Value is too small")=>t=>t>=e?[]:[r],e.hasChar=(e="",r="Missing required character")=>(o(e)&&(e=e.split("")),t=>{if(!o(t))return[];for(let r=0,n=e.length;r<n;r++)if(t.indexOf(e[r])>-1)return[];return[r]}),e.hasLowercase=(e="Requires a lowercase character")=>{var r=/[a-z]/;return t=>o(t)&&r.test(t)?[]:[e]},e.hasNumeric=(e="Requires a number")=>{var r=/\d/;return t=>o(t)&&r.test(t)?[]:[e]},e.hasUppercase=(e="Requires an uppercase character")=>{var r=/[A-Z]/;return t=>o(t)&&r.test(t)?[]:[e]},e.isNumeric=(e="Value is not a valid number")=>t=>r(t)?[]:isNaN(parseFloat(t))?[e]:[],e.lengthBetween=(e,r,t="Should be between "+e+" and "+r+" in length")=>n=>o(n)&&(n.length<e||n.length>r)?[t]:[],e.lessThan=(e,r="Value is too large")=>t=>t<e?[]:[r],e.lessThanOrEqualTo=(e,r="Value is too large")=>t=>t<=e?[]:[r],e.matches=(e,r="Value doesnt match pattern")=>(e=o(e)?new RegExp(e):e,t=>e.test(t)?[]:[r]),e.maxLength=(e,r="Too long")=>t=>o(t)&&t.length>e?[r]:[],e.minLength=(e,r="Not long enough")=>t=>o(t)&&t.length<e?[r]:[],e.notDefault=(e,r="This is required")=>(e=Array.isArray(e)?e:[e],t=>{for(let n=0,a=e.length;n<a;n++)if(t===e[n])return[r];return[]}),e.notEqualTo=(e,r="Values should not be the same")=>{var n=t(e)?e:()=>e;return e=>n()!==e?[]:[r]},e.required=(e="Required")=>r=>r?[]:[e],Object.defineProperty(e,"__esModule",{value:!0}),e}({});
//# sourceMappingURL=fn-validate.min.js.map
