"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const e=e=>"string"==typeof e||e instanceof String,r=(r,t="Value doesnt match pattern")=>(r=e(r)?new RegExp(r):r,e=>r.test(e)?[]:[t]);function t(e){return!("function"!=typeof e||!e.call)}const n=e=>e instanceof Promise;const o=/^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;exports.allowedChars=(e=!0,t=!0,n=!0,o="",s="Value contains restricted characters")=>{let a="^[";return e&&(a+="a-z"),t&&(a+="A-Z"),n&&(a+="0-9"),o&&(a+=o.replace(/[-/\\^$*+?.()|[\]{}]/g,"\\$&")),a+="]*$",r(new RegExp(a),s)},exports.between=(e,r,t="Should be between "+e+" and "+r)=>n=>{let o=parseFloat(n);return!isNaN(o)&&(n<e||n>r)?[t]:[]},exports.combine=function(e,r){if(!Array.isArray(e))throw new Error("combine requires that validators are an array of functions");if(0===e.length)return()=>[];for(let r=0,n=e.length;r<n;r++)if(!t(e[r]))throw new Error("Each validator needs to be a function");return 1===e.length?e:!0===r?r=>e.reduce(((e,t)=>e.concat(t(r))),[]):r=>{for(const t of e){let e=t(r);if(e.length>0)return e}return[]}},exports.combineAsync=function(e,r=!1){if(!Array.isArray(e))throw new Error("combineAsync requires that validators are an array of functions");if(0===e.length)return()=>Promise.resolve([]);for(let r=0,n=e.length;r<n;r++)if(!t(e[r]))throw new Error("Each validator needs to be a function");if(1===e.length){const r=e[0];return e=>{var t=r(e);return n(t)?t:Promise.resolve(t)}}return r?r=>function(e,r){const t=e.map((e=>{const t=e(r);return n(t)?t:Promise.resolve(t)}));return Promise.all(t).then((e=>e.reduce(((e,r)=>e.concat(r)),[])))}(e,r):r=>function(e,r){return new Promise(((t,o)=>{let s=!1,a=e.length;for(let i=0,u=e.length;i<u;i++){if(s)return;try{const u=e[i](r),l=n(u);if(!l&&u.length>0){s=!0,t(u);break}l?u.then((e=>{e.length>0?(s=!0,t(e)):0==--a&&t([])})).catch(o):0==--a&&t([])}catch(e){o(e)}}}))}(e,r)},exports.custom=(e,r="Value is incorrect")=>{if(!t(e))throw new Error("func needs to be a function");return t=>e(t)?[]:[r]},exports.customAsync=function(e,r="Value is incorrect"){if(!t(e))throw new Error("func needs to be a function");return t=>{const o=e(t);return n(o)?o.then((e=>e?[]:[r])):Promise.resolve(o?[]:[r])}},exports.email=(e="Email address is not valid")=>r=>o.test(r)?[]:[e],exports.equalTo=(e,r="Values are not equal")=>{var n=t(e)?e:()=>e;return e=>n()===e?[]:[r]},exports.greaterThan=(e,r="Value is too small")=>t=>t>e?[]:[r],exports.greaterThanOrEqualTo=(e,r="Value is too small")=>t=>t>=e?[]:[r],exports.hasChar=(r="",t="Missing required character")=>(e(r)&&(r=r.split("")),n=>{if(!e(n))return[];for(let e=0,t=r.length;e<t;e++)if(n.indexOf(r[e])>-1)return[];return[t]}),exports.hasLowercase=(r="Requires a lowercase character")=>{var t=/[a-z]/;return n=>e(n)&&t.test(n)?[]:[r]},exports.hasNumeric=(r="Requires a number")=>{var t=/\d/;return n=>e(n)&&t.test(n)?[]:[r]},exports.hasUppercase=(r="Requires an uppercase character")=>{var t=/[A-Z]/;return n=>e(n)&&t.test(n)?[]:[r]},exports.isNumeric=(e="Value is not a valid number")=>r=>"number"==typeof r?[]:isNaN(parseFloat(r))?[e]:[],exports.lengthBetween=(r,t,n="Should be between "+r+" and "+t+" in length")=>o=>e(o)&&(o.length<r||o.length>t)?[n]:[],exports.lessThan=(e,r="Value is too large")=>t=>t<e?[]:[r],exports.lessThanOrEqualTo=(e,r="Value is too large")=>t=>t<=e?[]:[r],exports.matches=r,exports.maxLength=(r,t="Too long")=>n=>e(n)&&n.length>r?[t]:[],exports.minLength=(r,t="Not long enough")=>n=>e(n)&&n.length<r?[t]:[],exports.notDefault=(e,r="This is required")=>(e=Array.isArray(e)?e:[e],t=>{for(let n=0,o=e.length;n<o;n++)if(t===e[n])return[r];return[]}),exports.notEqualTo=(e,r="Values should not be the same")=>{var n=t(e)?e:()=>e;return e=>n()!==e?[]:[r]},exports.required=(e="This is required")=>r=>r?[]:[e];
//# sourceMappingURL=fn-validate.cjs.js.map
